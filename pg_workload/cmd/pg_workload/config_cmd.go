package main

import (
	"bufio"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"golang.org/x/term"
	"gopkg.in/yaml.v3"

	"github.com/myorg/pg_tuner/pg_workload/internal/config"
	"github.com/myorg/pg_tuner/pg_workload/internal/database"
)

var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Configuration management commands",
	Long:  "Manage configuration: generate example configs, validate settings, test database connection.",
}

// Config command flags
var configCfgFlags struct {
	ConfigFile string
	Output     string
	Force      bool
}

var configInitCmd = &cobra.Command{
	Use:   "init",
	Short: "Generate example configuration file",
	Long: `Generate an example configuration file with default values.

Creates a YAML configuration file that you can customize for your environment.

Examples:
  pg_workload config init > config.yaml
  pg_workload config init --output config.yaml
`,
	RunE: runConfigInit,
}

var configValidateCmd = &cobra.Command{
	Use:   "validate [file]",
	Short: "Validate configuration file",
	Long: `Validate a configuration file for correctness.

Checks:
  - Valid YAML syntax
  - Required fields
  - Valid values for all settings
  - Database connection string format

Examples:
  pg_workload config validate config.yaml
  pg_workload config validate  # validates default config locations
`,
	Args: cobra.MaximumNArgs(1),
	RunE: runConfigValidate,
}

var configTestCmd = &cobra.Command{
	Use:   "test",
	Short: "Test database connection",
	Long: `Test the database connection using configuration.

Attempts to connect to the database and run basic health checks.

Examples:
  pg_workload config test
  pg_workload config test --config myconfig.yaml
`,
	RunE: runConfigTest,
}

var configShowCmd = &cobra.Command{
	Use:   "show",
	Short: "Show current configuration",
	Long: `Display the current configuration with all resolved values.

Shows the effective configuration after loading from file and applying defaults.

Examples:
  pg_workload config show
  pg_workload config show --config myconfig.yaml
`,
	RunE: runConfigShow,
}

var configSetupCmd = &cobra.Command{
	Use:   "setup",
	Short: "Interactive configuration setup",
	Long: `Interactively configure pg_workload settings.

Prompts for database connection details and optionally workload settings.
Tests the connection before saving the configuration.

The configuration is saved to ~/.pg_workload/config.yaml by default,
or to a custom path with --output.

Examples:
  pg_workload config setup
  pg_workload config setup --output ./config.yaml
  pg_workload config setup --full  # Also configure workload settings
`,
	RunE: runConfigSetup,
}

// Setup flags
var setupCfg struct {
	Output   string
	Full     bool
	NoTest   bool
	Force    bool
}

func init() {
	// Add subcommands to config
	configCmd.AddCommand(configInitCmd)
	configCmd.AddCommand(configSetupCmd)
	configCmd.AddCommand(configValidateCmd)
	configCmd.AddCommand(configTestCmd)
	configCmd.AddCommand(configShowCmd)

	// Common flags
	configCmd.PersistentFlags().StringVar(&configCfgFlags.ConfigFile, "config", "", "configuration file")

	// Init flags
	configInitCmd.Flags().StringVarP(&configCfgFlags.Output, "output", "o", "", "output file (default: stdout)")
	configInitCmd.Flags().BoolVarP(&configCfgFlags.Force, "force", "f", false, "overwrite existing file")

	// Setup flags
	configSetupCmd.Flags().StringVarP(&setupCfg.Output, "output", "o", "", "output file (default: ~/.pg_workload/config.yaml)")
	configSetupCmd.Flags().BoolVar(&setupCfg.Full, "full", false, "also configure workload settings")
	configSetupCmd.Flags().BoolVar(&setupCfg.NoTest, "no-test", false, "skip connection test")
	configSetupCmd.Flags().BoolVarP(&setupCfg.Force, "force", "f", false, "overwrite existing file without confirmation")
}

func runConfigInit(cmd *cobra.Command, args []string) error {
	template := `# pg_workload Configuration File
# Generated by pg_workload config init

# Database connection settings
database:
  host: localhost
  port: 5432
  user: postgres
  password: postgres
  dbname: postgres
  # Optional: connection string (overrides above)
  # connection_string: "postgresql://user:pass@host:5432/dbname"

# Workload settings
workload:
  # Mode: burst or simulation
  mode: burst

  # Profile to use
  profile: oltp_standard

  # Test duration
  duration: 15m

  # Warmup and cooldown periods (burst mode)
  warmup: 2m
  cooldown: 1m

  # Concurrency settings
  workers: 4
  connections: 10

  # Random seed for reproducibility
  seed: 42

# Data settings
data:
  # Scale factor (1 = 10K accounts)
  scale: 1

  # For large datasets, use preload instead of scale
  # preload_size: 10GB
  # preload_parallel: 4

# Simulation mode settings (only used when mode=simulation)
simulation:
  # Time compression factor (1-24)
  time_scale: 12

  # Simulation start time (HH:MM or YYYY-MM-DDTHH:MM:SS)
  # start_time: "09:00"

  # Clock mode: real or simulated
  clock: simulated

  # Storage limits
  max_storage: 500MB
  raw_retention: 10m
  aggregate_interval: 1m

# Output settings
output:
  # Report output file (JSON)
  # file: results.json

  # Timeline output for simulation (CSV)
  # timeline: timeline.csv

  # Quiet mode (suppress progress)
  quiet: false

# Schema settings
schema:
  # Skip schema creation
  skip_setup: false

  # Skip schema cleanup
  skip_cleanup: false
`

	if configCfgFlags.Output != "" {
		// Check if file exists
		if !configCfgFlags.Force {
			if _, err := os.Stat(configCfgFlags.Output); err == nil {
				return fmt.Errorf("file %s already exists (use --force to overwrite)", configCfgFlags.Output)
			}
		}

		// Ensure directory exists
		dir := filepath.Dir(configCfgFlags.Output)
		if dir != "." && dir != "" {
			if err := os.MkdirAll(dir, 0755); err != nil {
				return fmt.Errorf("creating directory: %w", err)
			}
		}

		if err := os.WriteFile(configCfgFlags.Output, []byte(template), 0644); err != nil {
			return fmt.Errorf("writing file: %w", err)
		}

		fmt.Printf("Configuration written to %s\n", configCfgFlags.Output)
		return nil
	}

	// Output to stdout
	fmt.Print(template)
	return nil
}

func runConfigValidate(cmd *cobra.Command, args []string) error {
	var configFile string

	if len(args) > 0 {
		configFile = args[0]
	} else if configCfgFlags.ConfigFile != "" {
		configFile = configCfgFlags.ConfigFile
	} else {
		// Try default locations
		defaults := []string{
			"config.yaml",
			"config.yml",
			"pg_workload.yaml",
			"pg_workload.yml",
			filepath.Join(os.Getenv("HOME"), ".pg_workload", "config.yaml"),
		}

		for _, f := range defaults {
			if _, err := os.Stat(f); err == nil {
				configFile = f
				break
			}
		}

		if configFile == "" {
			return fmt.Errorf("no configuration file found, specify with --config or create config.yaml")
		}
	}

	fmt.Printf("Validating: %s\n", configFile)
	fmt.Println()

	// Read file
	data, err := os.ReadFile(configFile)
	if err != nil {
		return fmt.Errorf("reading file: %w", err)
	}

	// Parse YAML
	var raw map[string]interface{}
	if err := yaml.Unmarshal(data, &raw); err != nil {
		return fmt.Errorf("invalid YAML syntax: %w", err)
	}

	// Try loading with config package
	cfg, err := config.LoadConfig(configFile)
	if err != nil {
		fmt.Println("Errors:")
		fmt.Printf("  - Failed to load config: %v\n", err)
		return fmt.Errorf("validation failed")
	}

	// Validate sections
	var warnings []string

	// Database validation
	if cfg.Database.Host == "" {
		warnings = append(warnings, "database.host is empty (will use localhost)")
	}
	if cfg.Database.User == "" {
		warnings = append(warnings, "database.user is empty")
	}
	if cfg.Database.DBName == "" {
		warnings = append(warnings, "database.dbname is empty (will use postgres)")
	}

	// Workload validation
	if cfg.Workload.Workers < 1 {
		warnings = append(warnings, "workload.workers should be >= 1")
	}
	if cfg.Workload.Connections < cfg.Workload.Workers {
		warnings = append(warnings, "workload.connections should be >= workers")
	}
	if cfg.Workload.Duration < time.Minute {
		warnings = append(warnings, "workload.duration is less than 1 minute")
	}

	// Print warnings
	if len(warnings) > 0 {
		fmt.Println("Warnings:")
		for _, w := range warnings {
			fmt.Printf("  - %s\n", w)
		}
		fmt.Println()
	}

	fmt.Println("Configuration is valid")
	fmt.Println()

	// Print summary
	fmt.Println("Summary:")
	fmt.Printf("  Database: %s@%s:%d/%s\n",
		cfg.Database.User, cfg.Database.Host, cfg.Database.Port, cfg.Database.DBName)
	fmt.Printf("  Mode:     %s\n", cfg.Workload.Mode)
	fmt.Printf("  Profile:  %s\n", cfg.Workload.Profile)
	fmt.Printf("  Duration: %s\n", cfg.Workload.Duration)
	fmt.Printf("  Workers:  %d\n", cfg.Workload.Workers)

	return nil
}

func runConfigTest(cmd *cobra.Command, args []string) error {
	var cfg *config.Config

	if configCfgFlags.ConfigFile != "" {
		var err error
		cfg, err = config.LoadConfig(configCfgFlags.ConfigFile)
		if err != nil {
			return fmt.Errorf("loading config: %w", err)
		}
	} else {
		cfg = config.LoadConfigWithDefaults()
	}

	fmt.Printf("Testing connection to %s@%s:%d/%s...\n",
		cfg.Database.User, cfg.Database.Host, cfg.Database.Port, cfg.Database.DBName)
	fmt.Println()

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	poolCfg := database.PoolConfig{
		MinConns:          1,
		MaxConns:          2,
		MaxConnLifetime:   5 * time.Minute,
		MaxConnIdleTime:   1 * time.Minute,
		HealthCheckPeriod: 30 * time.Second,
	}

	startTime := time.Now()
	pool, err := database.NewPoolWithConfig(ctx, &cfg.Database, poolCfg)
	connectTime := time.Since(startTime)

	if err != nil {
		fmt.Printf("Connection failed: %v\n", err)
		return fmt.Errorf("connection failed")
	}
	defer pool.Close()

	fmt.Printf("Connected in %s\n", connectTime.Round(time.Millisecond))

	// Health check
	if err := pool.HealthCheck(ctx); err != nil {
		fmt.Printf("Health check failed: %v\n", err)
		return fmt.Errorf("health check failed")
	}
	fmt.Println("Health check passed")

	// Get PostgreSQL version
	var version string
	err = pool.Pool().QueryRow(ctx, "SELECT version()").Scan(&version)
	if err == nil {
		// Truncate version string
		if len(version) > 60 {
			version = version[:60] + "..."
		}
		fmt.Printf("PostgreSQL: %s\n", version)
	}

	// Get database size
	var dbSize string
	err = pool.Pool().QueryRow(ctx,
		"SELECT pg_size_pretty(pg_database_size(current_database()))").Scan(&dbSize)
	if err == nil {
		fmt.Printf("Database size: %s\n", dbSize)
	}

	// Check if OLTP tables exist
	var tableCount int
	err = pool.Pool().QueryRow(ctx, `
		SELECT COUNT(*) FROM information_schema.tables
		WHERE table_schema = 'public'
		AND table_name IN ('customers', 'branches', 'accounts', 'transactions')
	`).Scan(&tableCount)
	if err == nil {
		if tableCount > 0 {
			fmt.Printf("OLTP tables: %d/4 present\n", tableCount)
		} else {
			fmt.Println("OLTP tables: not created (use 'pg_workload schema create')")
		}
	}

	fmt.Println()
	fmt.Println("Connection test successful")

	return nil
}

func runConfigShow(cmd *cobra.Command, args []string) error {
	var cfg *config.Config
	var source string

	if configCfgFlags.ConfigFile != "" {
		var err error
		cfg, err = config.LoadConfig(configCfgFlags.ConfigFile)
		if err != nil {
			return fmt.Errorf("loading config: %w", err)
		}
		source = configCfgFlags.ConfigFile
	} else {
		cfg = config.LoadConfigWithDefaults()
		source = "defaults"
	}

	fmt.Printf("Configuration (source: %s)\n", source)
	fmt.Println("============================")
	fmt.Println()

	// Print as YAML
	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("formatting config: %w", err)
	}

	fmt.Print(string(data))

	return nil
}

func runConfigSetup(cmd *cobra.Command, args []string) error {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("pg_workload Configuration Setup")
	fmt.Println("================================")
	fmt.Println()

	// Database settings
	fmt.Println("Database Connection")
	fmt.Println("-------------------")

	host := promptWithDefault(reader, "Host", "localhost")
	portStr := promptWithDefault(reader, "Port", "5432")
	port, err := strconv.Atoi(portStr)
	if err != nil {
		port = 5432
	}
	user := promptWithDefault(reader, "User", "postgres")
	password := promptPassword("Password")
	dbname := promptWithDefault(reader, "Database name", "postgres")

	// Build database config
	dbCfg := config.DatabaseConfig{
		Host:     host,
		Port:     port,
		User:     user,
		Password: password,
		DBName:   dbname,
	}

	// Test connection unless --no-test
	if !setupCfg.NoTest {
		fmt.Println()
		fmt.Printf("Testing connection to %s@%s:%d/%s...\n", user, host, port, dbname)

		ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
		defer cancel()

		poolCfg := database.PoolConfig{
			MinConns:          1,
			MaxConns:          2,
			MaxConnLifetime:   5 * time.Minute,
			MaxConnIdleTime:   1 * time.Minute,
			HealthCheckPeriod: 30 * time.Second,
		}

		pool, err := database.NewPoolWithConfig(ctx, &dbCfg, poolCfg)
		if err != nil {
			fmt.Printf("Connection failed: %v\n", err)
			fmt.Println()

			retry := promptWithDefault(reader, "Retry with different settings? [y/N]", "n")
			if strings.ToLower(retry) == "y" {
				return runConfigSetup(cmd, args)
			}
			return fmt.Errorf("connection failed, configuration not saved")
		}
		pool.Close()

		fmt.Println("Connection successful!")
	}

	// Workload settings (if --full)
	workloadCfg := config.WorkloadConfig{
		Mode:        "burst",
		Profile:     "oltp_standard",
		Duration:    15 * time.Minute,
		Warmup:      2 * time.Minute,
		Cooldown:    1 * time.Minute,
		Workers:     4,
		Connections: 10,
		Seed:        42,
	}

	if setupCfg.Full {
		fmt.Println()
		fmt.Println("Workload Settings")
		fmt.Println("-----------------")

		mode := promptWithDefault(reader, "Mode (burst/simulation)", "burst")
		if mode != "burst" && mode != "simulation" {
			mode = "burst"
		}
		workloadCfg.Mode = mode

		durationStr := promptWithDefault(reader, "Duration", "15m")
		if d, err := time.ParseDuration(durationStr); err == nil {
			workloadCfg.Duration = d
		}

		workersStr := promptWithDefault(reader, "Workers", "4")
		if w, err := strconv.Atoi(workersStr); err == nil && w > 0 {
			workloadCfg.Workers = w
		}

		connsStr := promptWithDefault(reader, "Connections", "10")
		if c, err := strconv.Atoi(connsStr); err == nil && c > 0 {
			workloadCfg.Connections = c
		}
	}

	// Build full config
	cfg := &config.Config{
		Database: dbCfg,
		Workload: workloadCfg,
		Output:   config.OutputConfig{},
	}

	// Determine output path
	outputPath := setupCfg.Output
	if outputPath == "" {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			homeDir = "."
		}
		outputPath = filepath.Join(homeDir, ".pg_workload", "config.yaml")
	}

	// Check if file exists
	if !setupCfg.Force {
		if _, err := os.Stat(outputPath); err == nil {
			fmt.Printf("\nFile %s already exists.\n", outputPath)
			overwrite := promptWithDefault(reader, "Overwrite? [y/N]", "n")
			if strings.ToLower(overwrite) != "y" {
				fmt.Println("Configuration not saved.")
				return nil
			}
		}
	}

	// Create directory if needed
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("creating directory: %w", err)
	}

	// Generate YAML with comments
	configContent := generateConfigYAML(cfg)

	// Write file
	if err := os.WriteFile(outputPath, []byte(configContent), 0600); err != nil {
		return fmt.Errorf("writing config: %w", err)
	}

	fmt.Println()
	fmt.Printf("Configuration saved to %s\n", outputPath)
	fmt.Println()
	fmt.Println("You can now run:")
	fmt.Printf("  pg_workload run --config %s\n", outputPath)
	fmt.Println()
	fmt.Println("Or set as default:")
	fmt.Printf("  export PG_WORKLOAD_CONFIG=%s\n", outputPath)

	return nil
}

func promptWithDefault(reader *bufio.Reader, prompt, defaultVal string) string {
	if defaultVal != "" {
		fmt.Printf("%s [%s]: ", prompt, defaultVal)
	} else {
		fmt.Printf("%s: ", prompt)
	}

	input, err := reader.ReadString('\n')
	if err != nil {
		return defaultVal
	}

	input = strings.TrimSpace(input)
	if input == "" {
		return defaultVal
	}
	return input
}

func promptPassword(prompt string) string {
	fmt.Printf("%s: ", prompt)

	// Try to read password without echo
	if term.IsTerminal(int(os.Stdin.Fd())) {
		password, err := term.ReadPassword(int(os.Stdin.Fd()))
		fmt.Println() // New line after password
		if err != nil {
			return ""
		}
		return string(password)
	}

	// Fallback for non-terminal (e.g., piped input)
	reader := bufio.NewReader(os.Stdin)
	input, err := reader.ReadString('\n')
	if err != nil {
		return ""
	}
	return strings.TrimSpace(input)
}

func generateConfigYAML(cfg *config.Config) string {
	var sb strings.Builder

	sb.WriteString("# pg_workload Configuration\n")
	sb.WriteString("# Generated by pg_workload config setup\n")
	sb.WriteString(fmt.Sprintf("# Created: %s\n", time.Now().Format("2006-01-02 15:04:05")))
	sb.WriteString("\n")

	sb.WriteString("# Database connection settings\n")
	sb.WriteString("database:\n")
	sb.WriteString(fmt.Sprintf("  host: %s\n", cfg.Database.Host))
	sb.WriteString(fmt.Sprintf("  port: %d\n", cfg.Database.Port))
	sb.WriteString(fmt.Sprintf("  user: %s\n", cfg.Database.User))
	sb.WriteString(fmt.Sprintf("  password: %s\n", cfg.Database.Password))
	sb.WriteString(fmt.Sprintf("  dbname: %s\n", cfg.Database.DBName))
	sb.WriteString("\n")

	sb.WriteString("# Workload settings\n")
	sb.WriteString("workload:\n")
	sb.WriteString(fmt.Sprintf("  mode: %s\n", cfg.Workload.Mode))
	sb.WriteString(fmt.Sprintf("  profile: %s\n", cfg.Workload.Profile))
	sb.WriteString(fmt.Sprintf("  duration: %s\n", cfg.Workload.Duration))
	sb.WriteString(fmt.Sprintf("  warmup: %s\n", cfg.Workload.Warmup))
	sb.WriteString(fmt.Sprintf("  cooldown: %s\n", cfg.Workload.Cooldown))
	sb.WriteString(fmt.Sprintf("  workers: %d\n", cfg.Workload.Workers))
	sb.WriteString(fmt.Sprintf("  connections: %d\n", cfg.Workload.Connections))
	sb.WriteString(fmt.Sprintf("  seed: %d\n", cfg.Workload.Seed))
	sb.WriteString("\n")

	sb.WriteString("# Output settings\n")
	sb.WriteString("output:\n")
	sb.WriteString("  # file: results.json\n")
	sb.WriteString("  # format: json\n")

	return sb.String()
}
