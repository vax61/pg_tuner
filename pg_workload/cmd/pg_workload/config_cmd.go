package main

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"

	"github.com/myorg/pg_tuner/pg_workload/internal/config"
	"github.com/myorg/pg_tuner/pg_workload/internal/database"
)

var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Configuration management commands",
	Long:  "Manage configuration: generate example configs, validate settings, test database connection.",
}

// Config command flags
var configCfgFlags struct {
	ConfigFile string
	Output     string
	Force      bool
}

var configInitCmd = &cobra.Command{
	Use:   "init",
	Short: "Generate example configuration file",
	Long: `Generate an example configuration file with default values.

Creates a YAML configuration file that you can customize for your environment.

Examples:
  pg_workload config init > config.yaml
  pg_workload config init --output config.yaml
`,
	RunE: runConfigInit,
}

var configValidateCmd = &cobra.Command{
	Use:   "validate [file]",
	Short: "Validate configuration file",
	Long: `Validate a configuration file for correctness.

Checks:
  - Valid YAML syntax
  - Required fields
  - Valid values for all settings
  - Database connection string format

Examples:
  pg_workload config validate config.yaml
  pg_workload config validate  # validates default config locations
`,
	Args: cobra.MaximumNArgs(1),
	RunE: runConfigValidate,
}

var configTestCmd = &cobra.Command{
	Use:   "test",
	Short: "Test database connection",
	Long: `Test the database connection using configuration.

Attempts to connect to the database and run basic health checks.

Examples:
  pg_workload config test
  pg_workload config test --config myconfig.yaml
`,
	RunE: runConfigTest,
}

var configShowCmd = &cobra.Command{
	Use:   "show",
	Short: "Show current configuration",
	Long: `Display the current configuration with all resolved values.

Shows the effective configuration after loading from file and applying defaults.

Examples:
  pg_workload config show
  pg_workload config show --config myconfig.yaml
`,
	RunE: runConfigShow,
}

func init() {
	// Add subcommands to config
	configCmd.AddCommand(configInitCmd)
	configCmd.AddCommand(configValidateCmd)
	configCmd.AddCommand(configTestCmd)
	configCmd.AddCommand(configShowCmd)

	// Common flags
	configCmd.PersistentFlags().StringVar(&configCfgFlags.ConfigFile, "config", "", "configuration file")

	// Init flags
	configInitCmd.Flags().StringVarP(&configCfgFlags.Output, "output", "o", "", "output file (default: stdout)")
	configInitCmd.Flags().BoolVarP(&configCfgFlags.Force, "force", "f", false, "overwrite existing file")
}

func runConfigInit(cmd *cobra.Command, args []string) error {
	template := `# pg_workload Configuration File
# Generated by pg_workload config init

# Database connection settings
database:
  host: localhost
  port: 5432
  user: postgres
  password: postgres
  dbname: postgres
  # Optional: connection string (overrides above)
  # connection_string: "postgresql://user:pass@host:5432/dbname"

# Workload settings
workload:
  # Mode: burst or simulation
  mode: burst

  # Profile to use
  profile: oltp_standard

  # Test duration
  duration: 15m

  # Warmup and cooldown periods (burst mode)
  warmup: 2m
  cooldown: 1m

  # Concurrency settings
  workers: 4
  connections: 10

  # Random seed for reproducibility
  seed: 42

# Data settings
data:
  # Scale factor (1 = 10K accounts)
  scale: 1

  # For large datasets, use preload instead of scale
  # preload_size: 10GB
  # preload_parallel: 4

# Simulation mode settings (only used when mode=simulation)
simulation:
  # Time compression factor (1-24)
  time_scale: 12

  # Simulation start time (HH:MM or YYYY-MM-DDTHH:MM:SS)
  # start_time: "09:00"

  # Clock mode: real or simulated
  clock: simulated

  # Storage limits
  max_storage: 500MB
  raw_retention: 10m
  aggregate_interval: 1m

# Output settings
output:
  # Report output file (JSON)
  # file: results.json

  # Timeline output for simulation (CSV)
  # timeline: timeline.csv

  # Quiet mode (suppress progress)
  quiet: false

# Schema settings
schema:
  # Skip schema creation
  skip_setup: false

  # Skip schema cleanup
  skip_cleanup: false
`

	if configCfgFlags.Output != "" {
		// Check if file exists
		if !configCfgFlags.Force {
			if _, err := os.Stat(configCfgFlags.Output); err == nil {
				return fmt.Errorf("file %s already exists (use --force to overwrite)", configCfgFlags.Output)
			}
		}

		// Ensure directory exists
		dir := filepath.Dir(configCfgFlags.Output)
		if dir != "." && dir != "" {
			if err := os.MkdirAll(dir, 0755); err != nil {
				return fmt.Errorf("creating directory: %w", err)
			}
		}

		if err := os.WriteFile(configCfgFlags.Output, []byte(template), 0644); err != nil {
			return fmt.Errorf("writing file: %w", err)
		}

		fmt.Printf("Configuration written to %s\n", configCfgFlags.Output)
		return nil
	}

	// Output to stdout
	fmt.Print(template)
	return nil
}

func runConfigValidate(cmd *cobra.Command, args []string) error {
	var configFile string

	if len(args) > 0 {
		configFile = args[0]
	} else if configCfgFlags.ConfigFile != "" {
		configFile = configCfgFlags.ConfigFile
	} else {
		// Try default locations
		defaults := []string{
			"config.yaml",
			"config.yml",
			"pg_workload.yaml",
			"pg_workload.yml",
			filepath.Join(os.Getenv("HOME"), ".pg_workload", "config.yaml"),
		}

		for _, f := range defaults {
			if _, err := os.Stat(f); err == nil {
				configFile = f
				break
			}
		}

		if configFile == "" {
			return fmt.Errorf("no configuration file found, specify with --config or create config.yaml")
		}
	}

	fmt.Printf("Validating: %s\n", configFile)
	fmt.Println()

	// Read file
	data, err := os.ReadFile(configFile)
	if err != nil {
		return fmt.Errorf("reading file: %w", err)
	}

	// Parse YAML
	var raw map[string]interface{}
	if err := yaml.Unmarshal(data, &raw); err != nil {
		return fmt.Errorf("invalid YAML syntax: %w", err)
	}

	// Try loading with config package
	cfg, err := config.LoadConfig(configFile)
	if err != nil {
		fmt.Println("Errors:")
		fmt.Printf("  - Failed to load config: %v\n", err)
		return fmt.Errorf("validation failed")
	}

	// Validate sections
	var warnings []string

	// Database validation
	if cfg.Database.Host == "" {
		warnings = append(warnings, "database.host is empty (will use localhost)")
	}
	if cfg.Database.User == "" {
		warnings = append(warnings, "database.user is empty")
	}
	if cfg.Database.DBName == "" {
		warnings = append(warnings, "database.dbname is empty (will use postgres)")
	}

	// Workload validation
	if cfg.Workload.Workers < 1 {
		warnings = append(warnings, "workload.workers should be >= 1")
	}
	if cfg.Workload.Connections < cfg.Workload.Workers {
		warnings = append(warnings, "workload.connections should be >= workers")
	}
	if cfg.Workload.Duration < time.Minute {
		warnings = append(warnings, "workload.duration is less than 1 minute")
	}

	// Print warnings
	if len(warnings) > 0 {
		fmt.Println("Warnings:")
		for _, w := range warnings {
			fmt.Printf("  - %s\n", w)
		}
		fmt.Println()
	}

	fmt.Println("Configuration is valid")
	fmt.Println()

	// Print summary
	fmt.Println("Summary:")
	fmt.Printf("  Database: %s@%s:%d/%s\n",
		cfg.Database.User, cfg.Database.Host, cfg.Database.Port, cfg.Database.DBName)
	fmt.Printf("  Mode:     %s\n", cfg.Workload.Mode)
	fmt.Printf("  Profile:  %s\n", cfg.Workload.Profile)
	fmt.Printf("  Duration: %s\n", cfg.Workload.Duration)
	fmt.Printf("  Workers:  %d\n", cfg.Workload.Workers)

	return nil
}

func runConfigTest(cmd *cobra.Command, args []string) error {
	var cfg *config.Config

	if configCfgFlags.ConfigFile != "" {
		var err error
		cfg, err = config.LoadConfig(configCfgFlags.ConfigFile)
		if err != nil {
			return fmt.Errorf("loading config: %w", err)
		}
	} else {
		cfg = config.LoadConfigWithDefaults()
	}

	fmt.Printf("Testing connection to %s@%s:%d/%s...\n",
		cfg.Database.User, cfg.Database.Host, cfg.Database.Port, cfg.Database.DBName)
	fmt.Println()

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	poolCfg := database.PoolConfig{
		MinConns:          1,
		MaxConns:          2,
		MaxConnLifetime:   5 * time.Minute,
		MaxConnIdleTime:   1 * time.Minute,
		HealthCheckPeriod: 30 * time.Second,
	}

	startTime := time.Now()
	pool, err := database.NewPoolWithConfig(ctx, &cfg.Database, poolCfg)
	connectTime := time.Since(startTime)

	if err != nil {
		fmt.Printf("Connection failed: %v\n", err)
		return fmt.Errorf("connection failed")
	}
	defer pool.Close()

	fmt.Printf("Connected in %s\n", connectTime.Round(time.Millisecond))

	// Health check
	if err := pool.HealthCheck(ctx); err != nil {
		fmt.Printf("Health check failed: %v\n", err)
		return fmt.Errorf("health check failed")
	}
	fmt.Println("Health check passed")

	// Get PostgreSQL version
	var version string
	err = pool.Pool().QueryRow(ctx, "SELECT version()").Scan(&version)
	if err == nil {
		// Truncate version string
		if len(version) > 60 {
			version = version[:60] + "..."
		}
		fmt.Printf("PostgreSQL: %s\n", version)
	}

	// Get database size
	var dbSize string
	err = pool.Pool().QueryRow(ctx,
		"SELECT pg_size_pretty(pg_database_size(current_database()))").Scan(&dbSize)
	if err == nil {
		fmt.Printf("Database size: %s\n", dbSize)
	}

	// Check if OLTP tables exist
	var tableCount int
	err = pool.Pool().QueryRow(ctx, `
		SELECT COUNT(*) FROM information_schema.tables
		WHERE table_schema = 'public'
		AND table_name IN ('customers', 'branches', 'accounts', 'transactions')
	`).Scan(&tableCount)
	if err == nil {
		if tableCount > 0 {
			fmt.Printf("OLTP tables: %d/4 present\n", tableCount)
		} else {
			fmt.Println("OLTP tables: not created (use 'pg_workload schema create')")
		}
	}

	fmt.Println()
	fmt.Println("Connection test successful")

	return nil
}

func runConfigShow(cmd *cobra.Command, args []string) error {
	var cfg *config.Config
	var source string

	if configCfgFlags.ConfigFile != "" {
		var err error
		cfg, err = config.LoadConfig(configCfgFlags.ConfigFile)
		if err != nil {
			return fmt.Errorf("loading config: %w", err)
		}
		source = configCfgFlags.ConfigFile
	} else {
		cfg = config.LoadConfigWithDefaults()
		source = "defaults"
	}

	fmt.Printf("Configuration (source: %s)\n", source)
	fmt.Println("============================")
	fmt.Println()

	// Print as YAML
	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("formatting config: %w", err)
	}

	fmt.Print(string(data))

	return nil
}
